package GeneticAlgorithmLogic;import Common.DataQuery;import GeneticAlgoritm.Shared;import java.util.List;public class Candidate implements Comparable<Candidate>{    private final int InputGeneCount = 16;    private final int LogicGateGeneCount = 15;    public int InputBinaryStringLength;    public int[] GeneSequence = new int[31];    public float Accuracy;    /**     * Constructor     * @param input_count The number of inputs this candidate should expect to handle     */    public Candidate(int input_count) {        this.InputBinaryStringLength = input_count;        this.GenerateGene();    }    public float EvaluateMultiple(List<DataQuery> l) throws Exception {        var correct = 0;        for (var t : l) {            if (this.EvaluateSingle(t)) {                correct++;            }        }        this.Accuracy = (float)correct / (float)l.size();        return this.Accuracy;    }    /**     * This function will evaluate a single query.     * @param d DataQuery to test     * @return The test passed     * @throws Exception     */    public boolean EvaluateSingle(DataQuery  d) throws Exception {        var inputint = d.GetInputsAsBoolean();        var i0 = inputint[this.GeneSequence[0]];        var i1 = inputint[this.GeneSequence[1]];        var i2 = inputint[this.GeneSequence[2]];        var i3 = inputint[this.GeneSequence[3]];        var i4 = inputint[this.GeneSequence[4]];        var i5 = inputint[this.GeneSequence[5]];        var i6 = inputint[this.GeneSequence[6]];        var i7 = inputint[this.GeneSequence[7]];        var i8 = inputint[this.GeneSequence[8]];        var i9 = inputint[this.GeneSequence[9]];        var i10 = inputint[this.GeneSequence[10]];        var i11 = inputint[this.GeneSequence[11]];        var i12 = inputint[this.GeneSequence[12]];        var i13 = inputint[this.GeneSequence[13]];        var i14 = inputint[this.GeneSequence[14]];        var i15 = inputint[this.GeneSequence[15]];        return ProcessLogicGate(                    ProcessLogicGate(                            ProcessLogicGate(                                ProcessLogicGate(i0, i1, this.GeneSequence[16]),                                ProcessLogicGate(i2, i3, this.GeneSequence[17]),                                this.GeneSequence[19]                            ),                            ProcessLogicGate(                                ProcessLogicGate(i4, i5, this.GeneSequence[19]),                                ProcessLogicGate(i6, i7, this.GeneSequence[20]),                                this.GeneSequence[21]                            ),                        this.GeneSequence[22]),                    ProcessLogicGate(                            ProcessLogicGate(                                    ProcessLogicGate(i8, i9, this.GeneSequence[23]),                                    ProcessLogicGate(i10, i11, this.GeneSequence[24]),                                    this.GeneSequence[25]                            ),                            ProcessLogicGate(                                    ProcessLogicGate(i12, i13, this.GeneSequence[26]),                                    ProcessLogicGate(i14, i15, this.GeneSequence[27]),                                    this.GeneSequence[28]                            ),                            this.GeneSequence[29]),                    this.GeneSequence[30]) == d.GetOutputAsBoolean();    }    /**     * This function will get the string representation of the gene     * @return     */    public String GetGeneString() {        var retobj = "";        for (var i : this.GeneSequence) {            retobj += i + ".";        }        return retobj.substring(0, retobj.length() - 1);    }    /**     * This function will process the logic gates     * @param a input a     * @param b input b     * @param operator operation index     * @return resulting binary output     * @throws Exception Thrown when the operator logic cannot be found     */    public boolean ProcessLogicGate(boolean a, boolean b, int operator) throws Exception {        switch (operator) {            case 0: return (a & b);            case 1: return (a | b);            case 2: return (a ^ b);            case 3: return !(a & b);            case 4: return !(a | b);            case 5: return !(a ^ b);            case 6: return (!a | b);            case 7: return (a | !b);        }        throw new Exception("Cannot find logical operator for " + operator);    }    /**     * This function will generate the gene sequence     */    public void GenerateGene() {        for (int i = 0; i < this.InputGeneCount; i++) {            GeneSequence[i] = Shared.GetRandomInt(0, InputBinaryStringLength);        }        for (int i = InputGeneCount; i < this.InputGeneCount + this.LogicGateGeneCount; i++) {            GeneSequence[i] = Shared.GetRandomInt(0, 8);        }    }    public Candidate MateWith(Candidate c) {        var gs_a = this.GeneSequence;        var gs_b = c.GeneSequence;        var intersection_point = Shared.GetRandomInt(1, this.GeneSequence.length - 1);        var newGeneSet = new int[this.GeneSequence.length];        for (int i = 0; i < intersection_point; i++) {            newGeneSet[i] = gs_a[i];        }        for (int i = intersection_point; i < this.GeneSequence.length; i++) {            newGeneSet[i] = gs_b[i];        }        var child = new Candidate(InputBinaryStringLength);        child.GeneSequence = newGeneSet;        return child;    }    public void Mutate() {        var intersection_point = Shared.GetRandomInt(0, this.GeneSequence.length);        if (intersection_point > this.LogicGateGeneCount) {            this.GeneSequence[intersection_point] = Shared.GetRandomInt(0, 8);        } else {            this.GeneSequence[intersection_point] = Shared.GetRandomInt(0, InputBinaryStringLength);        }    }    @Override    public String toString() {        return this.GetGeneString();    }    @Override    public int compareTo(Candidate o) {        if (o.Accuracy > this.Accuracy) return -1;        if (o.Accuracy < this.Accuracy) return 1;        return 0;    }}